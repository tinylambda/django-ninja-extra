{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django Ninja Extra Django Ninja Extra is a complete class-based fashion of building and setting up APIs at incredible speed with incredible performance. It utilizes Django Ninja core features without compromising speed. Key features: All Django-Ninja features : Easy : Designed to be easy to use and intuitive. FAST execution : Very high performance thanks to Pydantic and async support . Fast to code : Type hints and automatic docs lets you focus only on business logic. Standards-based : Based on the open standards for APIs: OpenAPI (previously known as Swagger) and JSON Schema . Django friendly : (obviously) has good integration with the Django core and ORM. Plus Extra : Class Based : Design your APIs in a class based fashion. Permissions : Protect endpoint(s) at ease with defined permissions and authorizations at route level or controller level. Dependency Injection : Controller classes supports dependency injection with python Injector or django_injector . Giving you the ability to inject API dependable services to APIController class and utilizing them where needed Requirements Python >= 3.6 django >= 2.1 pydantic >= 1.6 Django-Ninja >= 0.16.1 Django-Ninja Benchmark Django-Ninja-Extra uses Django-Ninja under the hood, it can be assumed that Django-Ninja-Extra has the same benchmark with Django-Ninja Full documentation, visit . Sample Project Django-Ninja-Tutorial Project, visit Installation pip install django-ninja-extra After installation, add ninja_extra to your INSTALLED_APPS INSTALLED_APPS = [ ... , 'ninja_extra' , ] Usage In your django project next to urls.py create new api.py file: from ninja_extra import NinjaExtraAPI , APIController , route , router api = NinjaExtraAPI () # function based definition @api . get ( \"/add\" , tags = [ 'Math' ]) def add ( request , a : int , b : int ): return { \"result\" : a + b } #class based definition @router ( '/' , tags = [ 'Math' ], permissions = []) class MathAPI ( APIController ): @route . get ( '/subtract' ,) def subtract ( self , a : int , b : int ): \"\"\"Subtracts a from b\"\"\" return { \"result\" : a - b } @route . get ( '/divide' ,) def divide ( self , a : int , b : int ): \"\"\"Divides a by b\"\"\" return { \"result\" : a / b } @route . get ( '/multiple' ,) def multiple ( self , a : int , b : int ): \"\"\"Multiples a with b\"\"\" return { \"result\" : a * b } api . register_controllers ( MathAPI ) Now go to urls.py and add the following: ... from django.urls import path from .api import api urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), # <---------- ! ] Interactive API docs Now go to http://127.0.0.1:8000/api/docs You will see the automatic interactive API documentation (provided by Swagger UI ): What next? To support this project, please give star it on Github API Throttling","title":"Index"},{"location":"#django-ninja-extra","text":"Django Ninja Extra is a complete class-based fashion of building and setting up APIs at incredible speed with incredible performance. It utilizes Django Ninja core features without compromising speed. Key features: All Django-Ninja features : Easy : Designed to be easy to use and intuitive. FAST execution : Very high performance thanks to Pydantic and async support . Fast to code : Type hints and automatic docs lets you focus only on business logic. Standards-based : Based on the open standards for APIs: OpenAPI (previously known as Swagger) and JSON Schema . Django friendly : (obviously) has good integration with the Django core and ORM. Plus Extra : Class Based : Design your APIs in a class based fashion. Permissions : Protect endpoint(s) at ease with defined permissions and authorizations at route level or controller level. Dependency Injection : Controller classes supports dependency injection with python Injector or django_injector . Giving you the ability to inject API dependable services to APIController class and utilizing them where needed","title":"Django Ninja Extra"},{"location":"#requirements","text":"Python >= 3.6 django >= 2.1 pydantic >= 1.6 Django-Ninja >= 0.16.1","title":"Requirements"},{"location":"#django-ninja-benchmark","text":"Django-Ninja-Extra uses Django-Ninja under the hood, it can be assumed that Django-Ninja-Extra has the same benchmark with Django-Ninja Full documentation, visit .","title":"Django-Ninja Benchmark"},{"location":"#sample-project","text":"Django-Ninja-Tutorial Project, visit","title":"Sample Project"},{"location":"#installation","text":"pip install django-ninja-extra After installation, add ninja_extra to your INSTALLED_APPS INSTALLED_APPS = [ ... , 'ninja_extra' , ]","title":"Installation"},{"location":"#usage","text":"In your django project next to urls.py create new api.py file: from ninja_extra import NinjaExtraAPI , APIController , route , router api = NinjaExtraAPI () # function based definition @api . get ( \"/add\" , tags = [ 'Math' ]) def add ( request , a : int , b : int ): return { \"result\" : a + b } #class based definition @router ( '/' , tags = [ 'Math' ], permissions = []) class MathAPI ( APIController ): @route . get ( '/subtract' ,) def subtract ( self , a : int , b : int ): \"\"\"Subtracts a from b\"\"\" return { \"result\" : a - b } @route . get ( '/divide' ,) def divide ( self , a : int , b : int ): \"\"\"Divides a by b\"\"\" return { \"result\" : a / b } @route . get ( '/multiple' ,) def multiple ( self , a : int , b : int ): \"\"\"Multiples a with b\"\"\" return { \"result\" : a * b } api . register_controllers ( MathAPI ) Now go to urls.py and add the following: ... from django.urls import path from .api import api urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), # <---------- ! ]","title":"Usage"},{"location":"#interactive-api-docs","text":"Now go to http://127.0.0.1:8000/api/docs You will see the automatic interactive API documentation (provided by Swagger UI ):","title":"Interactive API docs"},{"location":"#what-next","text":"To support this project, please give star it on Github API Throttling","title":"What next?"},{"location":"service_module_injector/","text":"Dependency Injection One of the core features of Django Ninja Extra APIController is its support dependency injection. Having the ability to inject services to the controller is as simple as overriding your controller constructor and defining a parameter with its type annotation. Under the hood, APIController __init__ is wrapped with python Injector library inject function. By so doing, it's easy to resolve APIController dependencies. During APIController class initialization, the injector instance is used to resolve the APIController instance, and parameters with annotations will be resolved automatically. Info Django-Ninja-Extra supports django_injector . There is no extra configuration needed. from ninja import File from ninja.files import UploadedFile from ninja_extra import NinjaExtraAPI , APIController , route , router class BucketFileUploadService : def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): pass def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): pass @router ( '/user_profile' ) class UserProfileController ( APIController ): def __init__ ( self , upload_service : BucketFileUploadService ): self . upload_service = upload_service @route . post ( '/upload' ) def upload_profile_pic ( self , file : UploadedFile = File ( ... )): self . upload_service . upload_file_to_s3 ( file = file ) return { 'message' , 'uploaded successfully' } api = NinjaExtraAPI ( title = 'Injector Test' ) api . register_controllers ( UserProfileController ) Module Registration There are different ways of registering injector Modules in a Django app. django_injector : if you are using django_inject, it has documentation on how to register a module. ninja_extra : you can provide module string path in INJECTOR_MODULES in NINJA_EXTRA field as shown below: NinjaExtra = { 'INJECTOR_MODULES' : [ 'myproject.app1.modules.SomeModule' , 'myproject.app2.modules.SomeAppModule' , ] } Create a module create a modules.py with the code below in your django-project import logging import os from typing import Any , cast from django.conf import Settings from injector import inject , Module , Binder , singleton logger = logging . getLogger () class BucketFileUpload : def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): raise NotImplementedError () def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): raise NotImplementedError () class InMemoryBucketFileUpload ( BucketFileUpload ): @inject def __init__ ( self , settings : Settings ): logger . info ( f \"===== Using InMemoryBucketFileUpload =======\" ) self . settings = cast ( Any , settings ) def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): logger . info ( f \"InMemoryBucketFileUpload ---- \" f \"upload_file_to_s3(file= {file.filename} , bucket_name {bucket_name} , acl= {acl} , file_key= {file_key} )\" ) if not file_key : return os . path . join ( self . settings . UPLOAD_FOLDER , file . filename ) return os . path . join ( self . settings . BASE_DIR , file_key ) def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): logger . info ( f \"InMemoryBucketFileUpload ---- upload_existing_file_to_s3(\" f \"filepath= {filepath} , file_key= {file_key} , \" f \"bucket_name= {bucket_name} , acl= {acl} , delete_file_afterwards= {delete_file_afterwards} )\" ) return filepath class FileServiceModule ( Module ): def configure ( self , binder : Binder ) -> None : binder . bind ( BucketFileUpload , to = InMemoryBucketFileUpload , scope = singleton ) Create a controller.py with the code below from ninja import File from ninja.files import UploadedFile from ninja_extra import NinjaExtraAPI , APIController , route , router from .modules import BucketFileUpload , InMemoryBucketFileUpload @router ( '/user_profile' ) class UserProfileController ( APIController ): def __init__ ( self , upload_service : BucketFileUpload ): self . upload_service = upload_service @route . post ( '/upload' ) def upload_profile_pic ( self , file : UploadedFile = File ( ... )): self . upload_service . upload_file_to_s3 ( file = file ) assert isinstance ( self . upload_service , InMemoryBucketFileUpload ) # True return { 'message' , 'uploaded successfully' } api = NinjaExtraAPI ( title = 'Injector Test' ) api . register_controllers ( UserProfileController ) Register your Module In your django settings.py , add your FileServiceModule module to the NinjaExtra settings ... MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware' , 'django.contrib.sessions.middleware.SessionMiddleware' , 'django.middleware.common.CommonMiddleware' , 'django.middleware.csrf.CsrfViewMiddleware' , 'django.contrib.auth.middleware.AuthenticationMiddleware' , 'django.contrib.messages.middleware.MessageMiddleware' , 'django.middleware.clickjacking.XFrameOptionsMiddleware' , ] NinjaExtra = { 'INJECTOR_MODULES' : [ 'myproject.modules.FileServiceModule' ] } ... Warning You are not only allowed to override your APIController constructor with parameter that don't have annotations Read more Python Injector","title":"Dependency Injection"},{"location":"service_module_injector/#dependency-injection","text":"One of the core features of Django Ninja Extra APIController is its support dependency injection. Having the ability to inject services to the controller is as simple as overriding your controller constructor and defining a parameter with its type annotation. Under the hood, APIController __init__ is wrapped with python Injector library inject function. By so doing, it's easy to resolve APIController dependencies. During APIController class initialization, the injector instance is used to resolve the APIController instance, and parameters with annotations will be resolved automatically. Info Django-Ninja-Extra supports django_injector . There is no extra configuration needed. from ninja import File from ninja.files import UploadedFile from ninja_extra import NinjaExtraAPI , APIController , route , router class BucketFileUploadService : def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): pass def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): pass @router ( '/user_profile' ) class UserProfileController ( APIController ): def __init__ ( self , upload_service : BucketFileUploadService ): self . upload_service = upload_service @route . post ( '/upload' ) def upload_profile_pic ( self , file : UploadedFile = File ( ... )): self . upload_service . upload_file_to_s3 ( file = file ) return { 'message' , 'uploaded successfully' } api = NinjaExtraAPI ( title = 'Injector Test' ) api . register_controllers ( UserProfileController )","title":"Dependency Injection"},{"location":"service_module_injector/#module-registration","text":"There are different ways of registering injector Modules in a Django app. django_injector : if you are using django_inject, it has documentation on how to register a module. ninja_extra : you can provide module string path in INJECTOR_MODULES in NINJA_EXTRA field as shown below: NinjaExtra = { 'INJECTOR_MODULES' : [ 'myproject.app1.modules.SomeModule' , 'myproject.app2.modules.SomeAppModule' , ] }","title":"Module Registration"},{"location":"service_module_injector/#create-a-module","text":"create a modules.py with the code below in your django-project import logging import os from typing import Any , cast from django.conf import Settings from injector import inject , Module , Binder , singleton logger = logging . getLogger () class BucketFileUpload : def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): raise NotImplementedError () def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): raise NotImplementedError () class InMemoryBucketFileUpload ( BucketFileUpload ): @inject def __init__ ( self , settings : Settings ): logger . info ( f \"===== Using InMemoryBucketFileUpload =======\" ) self . settings = cast ( Any , settings ) def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): logger . info ( f \"InMemoryBucketFileUpload ---- \" f \"upload_file_to_s3(file= {file.filename} , bucket_name {bucket_name} , acl= {acl} , file_key= {file_key} )\" ) if not file_key : return os . path . join ( self . settings . UPLOAD_FOLDER , file . filename ) return os . path . join ( self . settings . BASE_DIR , file_key ) def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): logger . info ( f \"InMemoryBucketFileUpload ---- upload_existing_file_to_s3(\" f \"filepath= {filepath} , file_key= {file_key} , \" f \"bucket_name= {bucket_name} , acl= {acl} , delete_file_afterwards= {delete_file_afterwards} )\" ) return filepath class FileServiceModule ( Module ): def configure ( self , binder : Binder ) -> None : binder . bind ( BucketFileUpload , to = InMemoryBucketFileUpload , scope = singleton ) Create a controller.py with the code below from ninja import File from ninja.files import UploadedFile from ninja_extra import NinjaExtraAPI , APIController , route , router from .modules import BucketFileUpload , InMemoryBucketFileUpload @router ( '/user_profile' ) class UserProfileController ( APIController ): def __init__ ( self , upload_service : BucketFileUpload ): self . upload_service = upload_service @route . post ( '/upload' ) def upload_profile_pic ( self , file : UploadedFile = File ( ... )): self . upload_service . upload_file_to_s3 ( file = file ) assert isinstance ( self . upload_service , InMemoryBucketFileUpload ) # True return { 'message' , 'uploaded successfully' } api = NinjaExtraAPI ( title = 'Injector Test' ) api . register_controllers ( UserProfileController )","title":"Create a module"},{"location":"service_module_injector/#register-your-module","text":"In your django settings.py , add your FileServiceModule module to the NinjaExtra settings ... MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware' , 'django.contrib.sessions.middleware.SessionMiddleware' , 'django.middleware.common.CommonMiddleware' , 'django.middleware.csrf.CsrfViewMiddleware' , 'django.contrib.auth.middleware.AuthenticationMiddleware' , 'django.contrib.messages.middleware.MessageMiddleware' , 'django.middleware.clickjacking.XFrameOptionsMiddleware' , ] NinjaExtra = { 'INJECTOR_MODULES' : [ 'myproject.modules.FileServiceModule' ] } ... Warning You are not only allowed to override your APIController constructor with parameter that don't have annotations Read more Python Injector","title":"Register your Module"},{"location":"settings/","text":"Settings Django-Ninja-Extra has some settings that can be overridden by adding a NINJA_EXTRA field in Django settings.py with some key-value pair as shown below: # Django project settings.py NINJA_EXTRA = { 'PAGINATION_CLASS' : \"ninja_extra.pagination.PageNumberPaginationExtra\" , 'PAGINATION_PER_PAGE' : 100 , 'INJECTOR_MODULES' : [], } You can override what you don't need. It is not necessary need to override everything. PAGINATION_CLASS It defines the default paginator class used by the paginate decorator function if a paginator class is not defined. default: ninja_extra.pagination.LimitOffsetPagination PAGINATION_PER_PAGE It defines the default page size that is passed to the PAGINATION_CLASS during instantiation. default: 100 INJECTOR_MODULES It contains a list of strings that defines the path to injector Module . default: []","title":"Settings"},{"location":"settings/#settings","text":"Django-Ninja-Extra has some settings that can be overridden by adding a NINJA_EXTRA field in Django settings.py with some key-value pair as shown below: # Django project settings.py NINJA_EXTRA = { 'PAGINATION_CLASS' : \"ninja_extra.pagination.PageNumberPaginationExtra\" , 'PAGINATION_PER_PAGE' : 100 , 'INJECTOR_MODULES' : [], } You can override what you don't need. It is not necessary need to override everything.","title":"Settings"},{"location":"settings/#pagination_class","text":"It defines the default paginator class used by the paginate decorator function if a paginator class is not defined. default: ninja_extra.pagination.LimitOffsetPagination","title":"PAGINATION_CLASS"},{"location":"settings/#pagination_per_page","text":"It defines the default page size that is passed to the PAGINATION_CLASS during instantiation. default: 100","title":"PAGINATION_PER_PAGE"},{"location":"settings/#injector_modules","text":"It contains a list of strings that defines the path to injector Module . default: []","title":"INJECTOR_MODULES"},{"location":"api_controller/","text":"Controller APIController is a borrowed term from the C# ASP.NET environment which is an MVC framework. Although Django is not an MVC framework, we can still mimic the concept generally just like any other programming concept. Django-Ninja-Extra APIController is modelled after C# ASP.NET ApiController, giving all OOP sense in creating your controller models and adapting recent software design patterns in your Django project. Why APIController in Django. I have worked with many API tools out there in python: DRF, FastAPI, Flask-Restful. Don't get me wrong, these are great libraries. I am a super fan of FastAPI and DRF. In fact, some features of Django-Ninja-Extra came from DRF I enjoyed Django ORM and Django-Ninja is a saving grace. It brought FastAPI to Django in one piece. I also value speed which Django-Ninja is best known for. APIController was born to extend Django-Ninja to class-based and be more flexible to adapt to recent software design patterns. If you enjoy class-based controls for building API, welcome aboard. class APIController ( ABC , metaclass = APIControllerModelMetaclass ): ... Model Properties permission_classes List of default permission classes defined in a controller router auth List of default Authentication instances. As described in Django-Ninja Authentication . default: [] api Instance of NinjaExtraAPI at runtime. default: None auto_import states whether APIController should added to auto_controller import list. default: True get_router(cls) return controller to router instance if present and raises Exception is absent. get_path_operations(cls) container dict of route definition which are pass to Django-Ninja at runtime add_operation_from_route_function(cls, route_function: RouteFunction) A method overload for add_api_operation add_api_operation(cls, ...) Adds APIController route definitions to path operation get_route_functions(cls) Gets all registered route in an APIController get_permissions(self) Returns list of permission_classes instances check_permissions(self) Check permission when route function is invoked check_object_permissions(self, obj: Any) Checks object permissions. This is not automated. However, when called, it triggers all permission_classes has_object_permission function, just like in DRF Usage Let's create an APIController to manage Django user model import uuid from typing import List from ninja import ModelSchema from ninja_extra import APIController , route , router , exceptions , status from ninja_extra.controllers.response import Detail from django.contrib.auth import get_user_model class UserSchema ( ModelSchema ): class Config : model = get_user_model () model_fields = [ 'username' , 'email' , 'first_name' ] @router ( '/users' ) class UsersController ( APIController ): user_model = get_user_model () @route . post ( '' ) def create_user ( self , user : UserSchema ): # just simulating created user return self . Id ( uuid . uuid4 ()) @route . generic ( '/{int:user_id}' , methods = [ 'put' , 'patch' ], response = UserSchema ) def update_user ( self , user_id : int ): \"\"\" Django Ninja will serialize Django ORM model to schema provided as `response`\"\"\" user = self . user_model . objects . filter ( id = user_id ) . first () if user : return user raise exceptions . NotFound ( f 'User with id: ` {user_id} ` not found' ) @route . delete ( '/{int:user_id}' , response = Detail ( status_code = status . HTTP_204_NO_CONTENT )) def delete_user ( self , user_id : int ): user = self . user_model . objects . filter ( id = user_id ) . first () if user : user . delete () return self . create_response ( '' , status_code = status . HTTP_204_NO_CONTENT ) raise exceptions . NotFound ( f 'User with id: ` {user_id} ` not found' ) @route . get ( '' , response = List [ UserSchema ]) def list_user ( self ): return self . user_model . objects . all () @route . get ( '/ {user_id} ' , response = UserSchema ) def get_user_by_id ( self , user_id : int ): user = self . user_model . objects . filter ( id = user_id ) . first () if user : return user raise exceptions . NotFound ( f 'User with id: ` {user_id} ` not found' )","title":"Index"},{"location":"api_controller/#controller","text":"APIController is a borrowed term from the C# ASP.NET environment which is an MVC framework. Although Django is not an MVC framework, we can still mimic the concept generally just like any other programming concept. Django-Ninja-Extra APIController is modelled after C# ASP.NET ApiController, giving all OOP sense in creating your controller models and adapting recent software design patterns in your Django project.","title":"Controller"},{"location":"api_controller/#why-apicontroller-in-django","text":"I have worked with many API tools out there in python: DRF, FastAPI, Flask-Restful. Don't get me wrong, these are great libraries. I am a super fan of FastAPI and DRF. In fact, some features of Django-Ninja-Extra came from DRF I enjoyed Django ORM and Django-Ninja is a saving grace. It brought FastAPI to Django in one piece. I also value speed which Django-Ninja is best known for. APIController was born to extend Django-Ninja to class-based and be more flexible to adapt to recent software design patterns. If you enjoy class-based controls for building API, welcome aboard. class APIController ( ABC , metaclass = APIControllerModelMetaclass ): ...","title":"Why APIController in Django."},{"location":"api_controller/#model-properties","text":"","title":"Model Properties"},{"location":"api_controller/#permission_classes","text":"List of default permission classes defined in a controller router","title":"permission_classes"},{"location":"api_controller/#auth","text":"List of default Authentication instances. As described in Django-Ninja Authentication . default: []","title":"auth"},{"location":"api_controller/#api","text":"Instance of NinjaExtraAPI at runtime. default: None","title":"api"},{"location":"api_controller/#auto_import","text":"states whether APIController should added to auto_controller import list. default: True","title":"auto_import"},{"location":"api_controller/#get_routercls","text":"return controller to router instance if present and raises Exception is absent.","title":"get_router(cls)"},{"location":"api_controller/#get_path_operationscls","text":"container dict of route definition which are pass to Django-Ninja at runtime","title":"get_path_operations(cls)"},{"location":"api_controller/#add_operation_from_route_functioncls-route_function-routefunction","text":"A method overload for add_api_operation","title":"add_operation_from_route_function(cls, route_function: RouteFunction)"},{"location":"api_controller/#add_api_operationcls","text":"Adds APIController route definitions to path operation","title":"add_api_operation(cls, ...)"},{"location":"api_controller/#get_route_functionscls","text":"Gets all registered route in an APIController","title":"get_route_functions(cls)"},{"location":"api_controller/#get_permissionsself","text":"Returns list of permission_classes instances","title":"get_permissions(self)"},{"location":"api_controller/#check_permissionsself","text":"Check permission when route function is invoked","title":"check_permissions(self)"},{"location":"api_controller/#check_object_permissionsself-obj-any","text":"Checks object permissions. This is not automated. However, when called, it triggers all permission_classes has_object_permission function, just like in DRF","title":"check_object_permissions(self, obj: Any)"},{"location":"api_controller/#usage","text":"Let's create an APIController to manage Django user model import uuid from typing import List from ninja import ModelSchema from ninja_extra import APIController , route , router , exceptions , status from ninja_extra.controllers.response import Detail from django.contrib.auth import get_user_model class UserSchema ( ModelSchema ): class Config : model = get_user_model () model_fields = [ 'username' , 'email' , 'first_name' ] @router ( '/users' ) class UsersController ( APIController ): user_model = get_user_model () @route . post ( '' ) def create_user ( self , user : UserSchema ): # just simulating created user return self . Id ( uuid . uuid4 ()) @route . generic ( '/{int:user_id}' , methods = [ 'put' , 'patch' ], response = UserSchema ) def update_user ( self , user_id : int ): \"\"\" Django Ninja will serialize Django ORM model to schema provided as `response`\"\"\" user = self . user_model . objects . filter ( id = user_id ) . first () if user : return user raise exceptions . NotFound ( f 'User with id: ` {user_id} ` not found' ) @route . delete ( '/{int:user_id}' , response = Detail ( status_code = status . HTTP_204_NO_CONTENT )) def delete_user ( self , user_id : int ): user = self . user_model . objects . filter ( id = user_id ) . first () if user : user . delete () return self . create_response ( '' , status_code = status . HTTP_204_NO_CONTENT ) raise exceptions . NotFound ( f 'User with id: ` {user_id} ` not found' ) @route . get ( '' , response = List [ UserSchema ]) def list_user ( self ): return self . user_model . objects . all () @route . get ( '/ {user_id} ' , response = UserSchema ) def get_user_by_id ( self , user_id : int ): user = self . user_model . objects . filter ( id = user_id ) . first () if user : return user raise exceptions . NotFound ( f 'User with id: ` {user_id} ` not found' )","title":"Usage"},{"location":"api_controller/api_controller_permission/","text":"APIController Permissions The concept of this permission system came from Django DRF . Permission checks are always run at the very start of the route function, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the request.user and request.auth properties to determine if the incoming request should be permitted. Permissions are used to grant or deny access for different classes of users to different parts of the API. The simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the IsAuthenticated class in Django Ninja Extra . A slightly less strict style of permission would be to allow full access to authenticated users, but allow read-only access to unauthenticated users. This corresponds to the IsAuthenticatedOrReadOnly class in Django Ninja Extra . Limitations of object level permissions During route function call, we can only has_permission in permissions list are called automatic. But since we don't have the object, we can only invoke has_object_permission if you use get_object_or_exception or get_object_or_none methods which are available to APIController. Custom permissions To implement a custom permission, override BasePermission and implement either, or both, of the following methods: .has_permission ( self , request : HttpRequest , controller : \"APIController\" ) .has_object_permission ( self , request : HttpRequest , controller : \"APIController\" , obj : Any ) Example from ninja_extra import permissions , APIController , router , route class ReadOnly ( permissions . BasePermission ): def has_permission ( self , request , view ): return request . method in permissions . SAFE_METHODS @router ( \"\" , permissions = [ permissions . IsAuthenticated | ReadOnly ]) class PermissionController ( APIController ): @route . get ( '/must_be_authenticated' , permissions = [ permissions . IsAuthenticated ]) def must_be_authenticated ( self , word : str ): return dict ( says = word ) Permissions Supported Operands & (and) eg: permissions.IsAuthenticated & ReadOnly | (or) eg: permissions.IsAuthenticated | ReadOnly ~ (not) eg: !(permissions.IsAuthenticated & ReadOnly)","title":"Controller Permissions"},{"location":"api_controller/api_controller_permission/#apicontroller-permissions","text":"The concept of this permission system came from Django DRF . Permission checks are always run at the very start of the route function, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the request.user and request.auth properties to determine if the incoming request should be permitted. Permissions are used to grant or deny access for different classes of users to different parts of the API. The simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the IsAuthenticated class in Django Ninja Extra . A slightly less strict style of permission would be to allow full access to authenticated users, but allow read-only access to unauthenticated users. This corresponds to the IsAuthenticatedOrReadOnly class in Django Ninja Extra .","title":"APIController Permissions"},{"location":"api_controller/api_controller_permission/#limitations-of-object-level-permissions","text":"During route function call, we can only has_permission in permissions list are called automatic. But since we don't have the object, we can only invoke has_object_permission if you use get_object_or_exception or get_object_or_none methods which are available to APIController.","title":"Limitations of object level permissions"},{"location":"api_controller/api_controller_permission/#custom-permissions","text":"To implement a custom permission, override BasePermission and implement either, or both, of the following methods: .has_permission ( self , request : HttpRequest , controller : \"APIController\" ) .has_object_permission ( self , request : HttpRequest , controller : \"APIController\" , obj : Any ) Example from ninja_extra import permissions , APIController , router , route class ReadOnly ( permissions . BasePermission ): def has_permission ( self , request , view ): return request . method in permissions . SAFE_METHODS @router ( \"\" , permissions = [ permissions . IsAuthenticated | ReadOnly ]) class PermissionController ( APIController ): @route . get ( '/must_be_authenticated' , permissions = [ permissions . IsAuthenticated ]) def must_be_authenticated ( self , word : str ): return dict ( says = word )","title":"Custom permissions"},{"location":"api_controller/api_controller_permission/#permissions-supported-operands","text":"& (and) eg: permissions.IsAuthenticated & ReadOnly | (or) eg: permissions.IsAuthenticated | ReadOnly ~ (not) eg: !(permissions.IsAuthenticated & ReadOnly)","title":"Permissions Supported Operands"},{"location":"api_controller/api_controller_route/","text":"APIController Route Decorator The route class is a function decorator, used to mark an instance function of an APIController class, as an endpoint. Info ControllerRoute or route is not the same with django-ninja router and can't be used interchangeably. For example from ninja_extra import route , APIController from ninja_extra.controllers import RouteFunction class MyController ( APIController ): @route . get ( '/test' ) def test ( self ): return { 'message' : 'test' } assert isinstance ( MyController . test , RouteFunction ) # true The route has predefined method that helps create the following operations and their names proceeds its operation GET POST PUT DELETE PATCH GENERIC-for operation combination eg: methods=['POST', 'PATCH'] Initialization Parameters path it's a required uniques endpoint path string methods it's required a collection of endpoint operational mode eg: ['POST', 'PUT'] auth defines endpoint authentication method. default: NOT_SET response defines dict[status_code, schema] or Schema . It is used validated returned response. default: NOT_SET operation_id it is an optional unique id that distinguishes operations in path view. default: NOT_SET summary it is an optional summary that describes your endpoint. default: None description it is an optional description that describes your endpoint. default: None tags It is a list of strings useful for endpoint grouping for documentation purpose. default: None deprecated it is an optional boolean parameter that declares an endpoint deprecated. default: None by_alias it is an optional parameter that is applied to filter response schema object. default: False exclude_unset it is an optional parameter that is applied to filter response schema object. default: False exclude_defaults it is an optional parameter that is applied to filter response schema object. default: False exclude_none it is an optional parameter that is applied to filter response schema object. default: False include_in_schema indicates whether an endpoint should appear on the swagger documentation. default: True url_name it gives a name to an endpoint which can be resolved using reverse function in django. default: None permissions defines collection route permission classes. default: None Most of these parameters are what is used in creating and endpoint in Django-Ninja, but it has been abstracted here to be for the same purpose on APIController class Async Route Definition Django-Ninja-Extra route class also supports async endpoint definition just like in Django-Ninja. This is only available on Django > 3.0. For Example import asyncio from ninja_extra import route , APIController from ninja_extra.controllers import AsyncRouteFunction class MyController ( APIController ): @route . get ( \"/say-after\" ) async def say_after ( self , delay : int , word : str ): await asyncio . sleep ( delay ) return { 'saying' : word } assert isinstance ( MyController . say_after , AsyncRouteFunction ) # true Info Read more on Django-Ninja Async Support","title":"Controller Routes"},{"location":"api_controller/api_controller_route/#apicontroller-route-decorator","text":"The route class is a function decorator, used to mark an instance function of an APIController class, as an endpoint. Info ControllerRoute or route is not the same with django-ninja router and can't be used interchangeably. For example from ninja_extra import route , APIController from ninja_extra.controllers import RouteFunction class MyController ( APIController ): @route . get ( '/test' ) def test ( self ): return { 'message' : 'test' } assert isinstance ( MyController . test , RouteFunction ) # true The route has predefined method that helps create the following operations and their names proceeds its operation GET POST PUT DELETE PATCH GENERIC-for operation combination eg: methods=['POST', 'PATCH']","title":"APIController Route Decorator"},{"location":"api_controller/api_controller_route/#initialization-parameters","text":"","title":"Initialization Parameters"},{"location":"api_controller/api_controller_route/#path","text":"it's a required uniques endpoint path string","title":"path"},{"location":"api_controller/api_controller_route/#methods","text":"it's required a collection of endpoint operational mode eg: ['POST', 'PUT']","title":"methods"},{"location":"api_controller/api_controller_route/#auth","text":"defines endpoint authentication method. default: NOT_SET","title":"auth"},{"location":"api_controller/api_controller_route/#response","text":"defines dict[status_code, schema] or Schema . It is used validated returned response. default: NOT_SET","title":"response"},{"location":"api_controller/api_controller_route/#operation_id","text":"it is an optional unique id that distinguishes operations in path view. default: NOT_SET","title":"operation_id"},{"location":"api_controller/api_controller_route/#summary","text":"it is an optional summary that describes your endpoint. default: None","title":"summary"},{"location":"api_controller/api_controller_route/#description","text":"it is an optional description that describes your endpoint. default: None","title":"description"},{"location":"api_controller/api_controller_route/#tags","text":"It is a list of strings useful for endpoint grouping for documentation purpose. default: None","title":"tags"},{"location":"api_controller/api_controller_route/#deprecated","text":"it is an optional boolean parameter that declares an endpoint deprecated. default: None","title":"deprecated"},{"location":"api_controller/api_controller_route/#by_alias","text":"it is an optional parameter that is applied to filter response schema object. default: False","title":"by_alias"},{"location":"api_controller/api_controller_route/#exclude_unset","text":"it is an optional parameter that is applied to filter response schema object. default: False","title":"exclude_unset"},{"location":"api_controller/api_controller_route/#exclude_defaults","text":"it is an optional parameter that is applied to filter response schema object. default: False","title":"exclude_defaults"},{"location":"api_controller/api_controller_route/#exclude_none","text":"it is an optional parameter that is applied to filter response schema object. default: False","title":"exclude_none"},{"location":"api_controller/api_controller_route/#include_in_schema","text":"indicates whether an endpoint should appear on the swagger documentation. default: True","title":"include_in_schema"},{"location":"api_controller/api_controller_route/#url_name","text":"it gives a name to an endpoint which can be resolved using reverse function in django. default: None","title":"url_name"},{"location":"api_controller/api_controller_route/#permissions","text":"defines collection route permission classes. default: None Most of these parameters are what is used in creating and endpoint in Django-Ninja, but it has been abstracted here to be for the same purpose on APIController class","title":"permissions"},{"location":"api_controller/api_controller_route/#async-route-definition","text":"Django-Ninja-Extra route class also supports async endpoint definition just like in Django-Ninja. This is only available on Django > 3.0. For Example import asyncio from ninja_extra import route , APIController from ninja_extra.controllers import AsyncRouteFunction class MyController ( APIController ): @route . get ( \"/say-after\" ) async def say_after ( self , delay : int , word : str ): await asyncio . sleep ( delay ) return { 'saying' : word } assert isinstance ( MyController . say_after , AsyncRouteFunction ) # true Info Read more on Django-Ninja Async Support","title":"Async Route Definition"},{"location":"api_controller/api_controller_router/","text":"APIController Router The ControllerRouter is router in short form, is an adapter class that adapts APIController classes to Django-Ninja router . During api.register_controllers call, the APIController _router is passed to the Django-Ninja for route processing. For this reason, APIController class can't be registered without having a ControllerRouter class decoration Controller Router Initialization Parameters prefix it is a required parameter that defines extra route prefix for all route functions defined in an APIController class auth It is an optional parameter that defines global auth for APIController classes. This can be overridden by route auth definition. default: NOT_SET tags It is an optional parameter that defines global tags for APIController classes. This can be overridden by route tags definition. default: None permissions It is an optional parameter that defines global permissions APIController classes. This can be overridden by route permissions definition. default: None controller: Optional[Type[\"APIController\"]] It is APIController class decorated Quick Usage from ninja.constants import NOT_SET from ninja_extra import APIController , router , NinjaExtraAPI router = router ( prefix = '' , auth = NOT_SET , tags = [ 'someTags' ], permissions = []) @router class MyRouterController ( APIController ): '''testing''' api = NinjaExtraAPI () api . register_controllers ( MyRouterController )","title":"Controller Router"},{"location":"api_controller/api_controller_router/#apicontroller-router","text":"The ControllerRouter is router in short form, is an adapter class that adapts APIController classes to Django-Ninja router . During api.register_controllers call, the APIController _router is passed to the Django-Ninja for route processing. For this reason, APIController class can't be registered without having a ControllerRouter class decoration","title":"APIController Router"},{"location":"api_controller/api_controller_router/#controller-router-initialization-parameters","text":"","title":"Controller Router Initialization Parameters"},{"location":"api_controller/api_controller_router/#prefix","text":"it is a required parameter that defines extra route prefix for all route functions defined in an APIController class","title":"prefix"},{"location":"api_controller/api_controller_router/#auth","text":"It is an optional parameter that defines global auth for APIController classes. This can be overridden by route auth definition. default: NOT_SET","title":"auth"},{"location":"api_controller/api_controller_router/#tags","text":"It is an optional parameter that defines global tags for APIController classes. This can be overridden by route tags definition. default: None","title":"tags"},{"location":"api_controller/api_controller_router/#permissions","text":"It is an optional parameter that defines global permissions APIController classes. This can be overridden by route permissions definition. default: None","title":"permissions"},{"location":"api_controller/api_controller_router/#controller-optionaltypeapicontroller","text":"It is APIController class decorated","title":"controller: Optional[Type[\"APIController\"]]"},{"location":"api_controller/api_controller_router/#quick-usage","text":"from ninja.constants import NOT_SET from ninja_extra import APIController , router , NinjaExtraAPI router = router ( prefix = '' , auth = NOT_SET , tags = [ 'someTags' ], permissions = []) @router class MyRouterController ( APIController ): '''testing''' api = NinjaExtraAPI () api . register_controllers ( MyRouterController )","title":"Quick Usage"},{"location":"tutorial/","text":"Tutorial / Reference This tutorial shows you how to use Django Ninja Extra with most of its features. And most especially assumes you know how to use Django Ninja Info A lot of content here is drawn from Django-Ninja. So a lot would make sense if you understand the Django-Ninja framework first. Installation pip install django-ninja-extra After installation, add ninja_extra to your INSTALLED_APPS INSTALLED_APPS = [ ... , 'ninja_extra' , ] Create a Django project (If you already have an existing Django project, skip to the next step). Start a new Django project (or use an existing one). django-admin startproject myproject First steps Let's create a module for our API. Create an api.py file in the same directory location as urls.py : api.py from ninja_extra import NinjaExtraAPI , route , APIController , router api = NinjaExtraAPI () # function definition using Django-Ninja default router @api . get ( \"/hello\" ) def hello ( request ): return \"Hello world\" Now go to urls.py and add the following: from django.contrib import admin from django.urls import path from .api import api urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), ] Defining operation methods \"Operation\" can be one of the HTTP \"methods\": GET POST PUT DELETE PATCH ... and more. These are Django-Ninja defined operations on the API or Django-Ninja router. The same operation is exposed to APIControllers with the route class. The route class is an extra decorator that converts APIController instance methods to route function or endpoint. On the other hand, the router here is a short form of the ControllerRouter class, an adapter class, which is an that only adapts APIController to the Django-Ninja router. It also provides global control of all routes defined in any APIController class. @router ( '' , tags = [ 'My Operations' ], auth = NOT_SET , permissions = []) class MyAPIController ( APIController ): @route . get ( \"/path\" ) def get_operation ( self ): ... @route . post ( \"/path\" ) def post_operation ( self ): ... @route . put ( \"/path\" ) def put_operation ( self ): ... @route . delete ( \"/path\" ) def delete_operation ( self ): ... @route . patch ( \"/path\" ) def patch_operation ( self ): ... # If you need to handle multiple methods with a single function, you can use the `generic` method as shown above @route . generic ([ \"POST\" , \"PATCH\" ]) def mixed ( request ): ... api . register_controllers ( MyAPIController ) To have a complete Controller setup, the APIController must be decorated with ControllerRouter before it's been registered.","title":"Quick Tutorial"},{"location":"tutorial/#tutorial-reference","text":"This tutorial shows you how to use Django Ninja Extra with most of its features. And most especially assumes you know how to use Django Ninja Info A lot of content here is drawn from Django-Ninja. So a lot would make sense if you understand the Django-Ninja framework first.","title":"Tutorial / Reference"},{"location":"tutorial/#installation","text":"pip install django-ninja-extra After installation, add ninja_extra to your INSTALLED_APPS INSTALLED_APPS = [ ... , 'ninja_extra' , ]","title":"Installation"},{"location":"tutorial/#create-a-django-project","text":"(If you already have an existing Django project, skip to the next step). Start a new Django project (or use an existing one). django-admin startproject myproject","title":"Create a Django project"},{"location":"tutorial/#first-steps","text":"Let's create a module for our API. Create an api.py file in the same directory location as urls.py : api.py from ninja_extra import NinjaExtraAPI , route , APIController , router api = NinjaExtraAPI () # function definition using Django-Ninja default router @api . get ( \"/hello\" ) def hello ( request ): return \"Hello world\" Now go to urls.py and add the following: from django.contrib import admin from django.urls import path from .api import api urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), ]","title":"First steps"},{"location":"tutorial/#defining-operation-methods","text":"\"Operation\" can be one of the HTTP \"methods\": GET POST PUT DELETE PATCH ... and more. These are Django-Ninja defined operations on the API or Django-Ninja router. The same operation is exposed to APIControllers with the route class. The route class is an extra decorator that converts APIController instance methods to route function or endpoint. On the other hand, the router here is a short form of the ControllerRouter class, an adapter class, which is an that only adapts APIController to the Django-Ninja router. It also provides global control of all routes defined in any APIController class. @router ( '' , tags = [ 'My Operations' ], auth = NOT_SET , permissions = []) class MyAPIController ( APIController ): @route . get ( \"/path\" ) def get_operation ( self ): ... @route . post ( \"/path\" ) def post_operation ( self ): ... @route . put ( \"/path\" ) def put_operation ( self ): ... @route . delete ( \"/path\" ) def delete_operation ( self ): ... @route . patch ( \"/path\" ) def patch_operation ( self ): ... # If you need to handle multiple methods with a single function, you can use the `generic` method as shown above @route . generic ([ \"POST\" , \"PATCH\" ]) def mixed ( request ): ... api . register_controllers ( MyAPIController ) To have a complete Controller setup, the APIController must be decorated with ControllerRouter before it's been registered.","title":"Defining operation methods"},{"location":"tutorial/authentication/","text":"Authentication Django Ninja Extra provides the same API for authorization and authentication as in Django-Ninja . Automatic OpenAPI schema Here's an example where the client, in order to authenticate, needs to pass a header: Authorization: Bearer supersecret from ninja.security import HttpBearer from ninja_extra import APIController , route , router from ninja.constants import NOT_SET class AuthBearer ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token @router ( '' , tags = [ 'My Operations' ], auth = NOT_SET , permissions = []) class MyController ( APIController ): @route . get ( \"/bearer\" , auth = AuthBearer ()) def bearer ( self ): return { \"token\" : self . request . auth } Global authentication In case you need to secure all route methods defined in api and APIController, you can pass the auth argument to the NinjaExtraAPI constructor: from ninja_extra import NinjaExtraAPI from ninja.security import HttpBearer class GlobalAuth ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token api = NinjaExtraAPI ( auth = GlobalAuth ()) Read more on django-ninja authentication JWT Authentication if you want to use JWT authentication. See ninja-jwt","title":"Authentication"},{"location":"tutorial/authentication/#authentication","text":"Django Ninja Extra provides the same API for authorization and authentication as in Django-Ninja .","title":"Authentication"},{"location":"tutorial/authentication/#automatic-openapi-schema","text":"Here's an example where the client, in order to authenticate, needs to pass a header: Authorization: Bearer supersecret from ninja.security import HttpBearer from ninja_extra import APIController , route , router from ninja.constants import NOT_SET class AuthBearer ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token @router ( '' , tags = [ 'My Operations' ], auth = NOT_SET , permissions = []) class MyController ( APIController ): @route . get ( \"/bearer\" , auth = AuthBearer ()) def bearer ( self ): return { \"token\" : self . request . auth }","title":"Automatic OpenAPI schema"},{"location":"tutorial/authentication/#global-authentication","text":"In case you need to secure all route methods defined in api and APIController, you can pass the auth argument to the NinjaExtraAPI constructor: from ninja_extra import NinjaExtraAPI from ninja.security import HttpBearer class GlobalAuth ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token api = NinjaExtraAPI ( auth = GlobalAuth ()) Read more on django-ninja authentication","title":"Global authentication"},{"location":"tutorial/authentication/#jwt-authentication","text":"if you want to use JWT authentication. See ninja-jwt","title":"JWT Authentication"},{"location":"tutorial/body_request/","text":"Request Body Request bodies are typically used with \u201ccreate\u201d and \u201cupdate\u201d operations (POST, PUT, PATCH). For example, when creating a resource using POST or PUT, the request body usually contains the representation of the resource to be created. To declare a request body , you need to use Django Ninja Schema or any Pydantic Schema that suits your need. I recommend Ninja-Schema Create your data model Then you declare your data model as a class that inherits from Schema . Use standard Python types for all the attributes: from ninja import Schema , constants from ninja_extra import APIController , route , router class Item ( Schema ): name : str description : str = None price : float quantity : int @router ( '' , tags = [ 'My Operations' ], auth = constants . NOT_SET , permissions = []) class MyAPIController ( APIController ): @route . post ( \"/items\" ) def create ( self , item : Item ): return item Note: if you use None as the default value for an attribute, it will become optional in the request body. For example, this model above declares a JSON \" object \" (or Python dict ) like: { \"name\" : \"Katana\" , \"description\" : \"An optional description\" , \"price\" : 299.00 , \"quantity\" : 10 } ...as description is optional (with a default value of None ), this JSON \" object \" would also be valid: { \"name\" : \"Katana\" , \"price\" : 299.00 , \"quantity\" : 10 }","title":"Body Request"},{"location":"tutorial/body_request/#request-body","text":"Request bodies are typically used with \u201ccreate\u201d and \u201cupdate\u201d operations (POST, PUT, PATCH). For example, when creating a resource using POST or PUT, the request body usually contains the representation of the resource to be created. To declare a request body , you need to use Django Ninja Schema or any Pydantic Schema that suits your need. I recommend Ninja-Schema","title":"Request Body"},{"location":"tutorial/body_request/#create-your-data-model","text":"Then you declare your data model as a class that inherits from Schema . Use standard Python types for all the attributes: from ninja import Schema , constants from ninja_extra import APIController , route , router class Item ( Schema ): name : str description : str = None price : float quantity : int @router ( '' , tags = [ 'My Operations' ], auth = constants . NOT_SET , permissions = []) class MyAPIController ( APIController ): @route . post ( \"/items\" ) def create ( self , item : Item ): return item Note: if you use None as the default value for an attribute, it will become optional in the request body. For example, this model above declares a JSON \" object \" (or Python dict ) like: { \"name\" : \"Katana\" , \"description\" : \"An optional description\" , \"price\" : 299.00 , \"quantity\" : 10 } ...as description is optional (with a default value of None ), this JSON \" object \" would also be valid: { \"name\" : \"Katana\" , \"price\" : 299.00 , \"quantity\" : 10 }","title":"Create your data model"},{"location":"tutorial/custom_exception/","text":"Custom Exception Django-Ninja provides an intuitive way of handling custom exceptions by registering a function(handler) against an Exception type, just like it's done in a Flask app. So in that sense, Django-Ninja-Extra has an APIException exception type which provides similar functionalities, for those use to DRF APIException . For Example: from ninja_extra.exceptions import APIException from ninja_extra import router , APIController , route , NinjaExtraAPI , status from ninja import constants class CustomAPIException ( APIException ): status_code = status . HTTP_401_UNAUTHORIZED message = 'UnAuthorized' @router ( '' , tags = [ 'My Operations' ], auth = constants . NOT_SET , permissions = []) class MyController ( APIController ): @route . get ( '/exception' ) def custom_exception ( self ): raise CustomAPIException () api = NinjaExtraAPI ( title = 'Exception Test' ) api . register_controllers ( MyController )","title":"Error Handling"},{"location":"tutorial/custom_exception/#custom-exception","text":"Django-Ninja provides an intuitive way of handling custom exceptions by registering a function(handler) against an Exception type, just like it's done in a Flask app. So in that sense, Django-Ninja-Extra has an APIException exception type which provides similar functionalities, for those use to DRF APIException . For Example: from ninja_extra.exceptions import APIException from ninja_extra import router , APIController , route , NinjaExtraAPI , status from ninja import constants class CustomAPIException ( APIException ): status_code = status . HTTP_401_UNAUTHORIZED message = 'UnAuthorized' @router ( '' , tags = [ 'My Operations' ], auth = constants . NOT_SET , permissions = []) class MyController ( APIController ): @route . get ( '/exception' ) def custom_exception ( self ): raise CustomAPIException () api = NinjaExtraAPI ( title = 'Exception Test' ) api . register_controllers ( MyController )","title":"Custom Exception"},{"location":"tutorial/form/","text":"If you are not sure how to make a form post request like application/x-www-form-urlencode or multipart/form-data in django-ninja-extra, then this guide would be useful for you. Django-Ninja already covers most of the use cases here , but I will give you a quick summary here. Form Data as Params from ninja import Form , constants from ninja_extra import APIController , route , router @router ( '' , tags = [ 'My Operations' ], auth = constants . NOT_SET , permissions = []) class MyAPIController ( APIController ): @route . post ( \"/login\" ) def login ( self , username : str = Form ( ... ), password : str = Form ( ... )): return { 'username' : username , 'password' : '*****' } Two things to note here: You need to import Form from ninja module Use Form as default value for your parameter Info For more information on this, visit Django-Ninja Form tutorial","title":"Form Request"},{"location":"tutorial/form/#form-data-as-params","text":"from ninja import Form , constants from ninja_extra import APIController , route , router @router ( '' , tags = [ 'My Operations' ], auth = constants . NOT_SET , permissions = []) class MyAPIController ( APIController ): @route . post ( \"/login\" ) def login ( self , username : str = Form ( ... ), password : str = Form ( ... )): return { 'username' : username , 'password' : '*****' } Two things to note here: You need to import Form from ninja module Use Form as default value for your parameter Info For more information on this, visit Django-Ninja Form tutorial","title":"Form Data as Params"},{"location":"tutorial/pagination/","text":"Pagination Django Ninja Extra provides an intuitive pagination model using paginate decoration from the Django-Ninja-Extra pagination module. It expects a List or Queryset from as a route function result. Properties def paginate(func_or_pgn_class: Any = NOT_SET, **paginator_params: Any) -> Callable[..., Any]: func_or_pgn_class: Defines a route function or a Pagination Class. default: ninja_extra.pagination.LimitOffsetPagination paginator_params: extra parameters for initialising Pagination Class Changing Default Pagination Class To change the default pagination class, you need to add a NINJA_EXTRA variable in settings.py with a key PAGINATION_CLASS and value defining path to pagination class # Django project settings.py INSTALLED_APPS = [ ... ] NINJA_EXTRA = { 'PAGINATION_CLASS' : 'ninja_extra.pagination.PageNumberPaginationExtra' } Usage from typing import List from ninja_extra.pagination import ( paginate , PageNumberPaginationExtra , PaginatedResponseSchema ) from ninja_extra import router , APIController , route , NinjaExtraAPI from ninja import ModelSchema from django.contrib.auth import get_user_model user_model = get_user_model () class UserSchema ( ModelSchema ): class Config : model = user_model model_fields = [ 'username' , 'email' ] @router ( '/users' ) class UserController ( APIController ): @route . get ( '' , response = PaginatedResponseSchema [ UserSchema ]) @paginate ( PageNumberPaginationExtra , page_size = 50 ) def get_users ( self ): return user_model . objects . all () @route . get ( '/limit' , response = List [ UserSchema ]) @paginate def get_users_with_limit ( self ): # this will use default paginator class - ninja_extra.pagination.LimitOffsetPagination return user_model . objects . all () api = NinjaExtraAPI ( title = 'Pagination Test' ) api . register_controllers ( UserController )","title":"Pagination"},{"location":"tutorial/pagination/#pagination","text":"Django Ninja Extra provides an intuitive pagination model using paginate decoration from the Django-Ninja-Extra pagination module. It expects a List or Queryset from as a route function result.","title":"Pagination"},{"location":"tutorial/pagination/#properties","text":"def paginate(func_or_pgn_class: Any = NOT_SET, **paginator_params: Any) -> Callable[..., Any]: func_or_pgn_class: Defines a route function or a Pagination Class. default: ninja_extra.pagination.LimitOffsetPagination paginator_params: extra parameters for initialising Pagination Class","title":"Properties"},{"location":"tutorial/pagination/#changing-default-pagination-class","text":"To change the default pagination class, you need to add a NINJA_EXTRA variable in settings.py with a key PAGINATION_CLASS and value defining path to pagination class # Django project settings.py INSTALLED_APPS = [ ... ] NINJA_EXTRA = { 'PAGINATION_CLASS' : 'ninja_extra.pagination.PageNumberPaginationExtra' }","title":"Changing Default Pagination Class"},{"location":"tutorial/pagination/#usage","text":"from typing import List from ninja_extra.pagination import ( paginate , PageNumberPaginationExtra , PaginatedResponseSchema ) from ninja_extra import router , APIController , route , NinjaExtraAPI from ninja import ModelSchema from django.contrib.auth import get_user_model user_model = get_user_model () class UserSchema ( ModelSchema ): class Config : model = user_model model_fields = [ 'username' , 'email' ] @router ( '/users' ) class UserController ( APIController ): @route . get ( '' , response = PaginatedResponseSchema [ UserSchema ]) @paginate ( PageNumberPaginationExtra , page_size = 50 ) def get_users ( self ): return user_model . objects . all () @route . get ( '/limit' , response = List [ UserSchema ]) @paginate def get_users_with_limit ( self ): # this will use default paginator class - ninja_extra.pagination.LimitOffsetPagination return user_model . objects . all () api = NinjaExtraAPI ( title = 'Pagination Test' ) api . register_controllers ( UserController )","title":"Usage"},{"location":"tutorial/path/","text":"Route path parameters are declared in python format-strings. for example: from ninja_extra import APIController , route , router from ninja import constants @router ( '' , tags = [ 'My Operations' ], auth = constants . NOT_SET , permissions = []) class MyAPIController ( APIController ): @route . get ( '/users/ {user_id} ' ) def get_user_by_id ( self , user_id : int ): return { 'user_id' : user_id } The value of the path parameter user_id will be passed to your function as the argument user_id . Info Read more","title":"Path Parameter"},{"location":"tutorial/query/","text":"Django-Ninja assumes function parameters that are not among path parameters as query parameters. For example: from ninja import constants from ninja_extra import APIController , route , router @router ( '' , tags = [ 'My Operations' ], auth = constants . NOT_SET , permissions = []) class MyAPIController ( APIController ): weapons = [ \"Ninjato\" , \"Shuriken\" , \"Katana\" , \"Kama\" , \"Kunai\" , \"Naginata\" , \"Yari\" ] @route . get ( \"/weapons\" ) def list_weapons ( self , limit : int = 10 , offset : int = 0 ): return self . weapons [ offset : offset + limit ] To query this operation, you use a URL like: http://localhost:8000/api/weapons?offset=0&limit=10 Info Read more","title":"Query Request"},{"location":"tutorial/schema/","text":"Django-Ninja Pydantic integration is one of the best features of Django-Ninja. With Pydantic, you can validate the inflow and outflow of data from your API, and It's very fast. Making a partial replacement of DRF serializers But if you want complete DRF Serializer replacement then Ninja-Schema is what you need. Ninja Schema Ninja Schema converts your Django ORM models to Pydantic schemas with more Pydantic features supported. Inspired by : django-ninja and djantic Key features: Custom Field Support : Ninja Schema converts django model to native pydantic types which gives you quick field validation out of the box. eg Enums, email, IPAddress, URLs, JSON, etc Field Validator : Fields can be validated with model_validator just like pydantic validator or root_validator . Info Visit Ninja Schema for More information","title":"Schema"},{"location":"tutorial/schema/#ninja-schema","text":"Ninja Schema converts your Django ORM models to Pydantic schemas with more Pydantic features supported. Inspired by : django-ninja and djantic Key features: Custom Field Support : Ninja Schema converts django model to native pydantic types which gives you quick field validation out of the box. eg Enums, email, IPAddress, URLs, JSON, etc Field Validator : Fields can be validated with model_validator just like pydantic validator or root_validator . Info Visit Ninja Schema for More information","title":"Ninja Schema"},{"location":"tutorial/testing/","text":"Testing APIController Django Ninja Extra has a TestClient that provides seamless testing of APIController classes with pytest There are two test clients TestClient : for synchronous route functions TestClientAsync : for asynchronous route functions from ninja_extra.testing import TestClient from ninja_extra import APIController , route , router from ninja_extra.permissions import AllowAny @router ( '' , tags = [ 'Math' ], permissions = [ AllowAny ]) class MyMathController ( APIController ): @route . get ( '/add' ,) def add ( self , a : int , b : int ): \"\"\"add a to b\"\"\" return { \"result\" : a - b } @route . get ( '/subtract' ,) def subtract ( self , a : int , b : int ): \"\"\"Subtracts a from b\"\"\" return { \"result\" : a - b } @route . get ( '/divide' ,) def divide ( self , a : int , b : int ): \"\"\"Divides a by b\"\"\" return { \"result\" : a / b } @route . get ( '/multiple' ,) def multiple ( self , a : int , b : int ): \"\"\"Multiples a with b\"\"\" return { \"result\" : a * b } class TestMyMathController : def test_add_endpoint_works ( self ): client = TestClient ( MyMathController ) response = client . post ( '/add' , query = dict ( a = 3 , b = 5 )) assert response . status_code == 200 data = response . json () assert 'result' in data assert data [ 'result' ] == 8 # true def test_substraction_enpoint_works ( self ): client = TestClient ( MyMathController ) response = client . post ( '/subtract' , query = dict ( a = 3 , b = 5 )) assert response . status_code == 200 data = response . json () assert 'result' in data assert data [ 'result' ] == - 2 # true","title":"Testing"},{"location":"tutorial/testing/#testing-apicontroller","text":"Django Ninja Extra has a TestClient that provides seamless testing of APIController classes with pytest There are two test clients TestClient : for synchronous route functions TestClientAsync : for asynchronous route functions from ninja_extra.testing import TestClient from ninja_extra import APIController , route , router from ninja_extra.permissions import AllowAny @router ( '' , tags = [ 'Math' ], permissions = [ AllowAny ]) class MyMathController ( APIController ): @route . get ( '/add' ,) def add ( self , a : int , b : int ): \"\"\"add a to b\"\"\" return { \"result\" : a - b } @route . get ( '/subtract' ,) def subtract ( self , a : int , b : int ): \"\"\"Subtracts a from b\"\"\" return { \"result\" : a - b } @route . get ( '/divide' ,) def divide ( self , a : int , b : int ): \"\"\"Divides a by b\"\"\" return { \"result\" : a / b } @route . get ( '/multiple' ,) def multiple ( self , a : int , b : int ): \"\"\"Multiples a with b\"\"\" return { \"result\" : a * b } class TestMyMathController : def test_add_endpoint_works ( self ): client = TestClient ( MyMathController ) response = client . post ( '/add' , query = dict ( a = 3 , b = 5 )) assert response . status_code == 200 data = response . json () assert 'result' in data assert data [ 'result' ] == 8 # true def test_substraction_enpoint_works ( self ): client = TestClient ( MyMathController ) response = client . post ( '/subtract' , query = dict ( a = 3 , b = 5 )) assert response . status_code == 200 data = response . json () assert 'result' in data assert data [ 'result' ] == - 2 # true","title":"Testing APIController"},{"location":"tutorial/versioning/","text":"Versioning Different API version numbers With Django Ninja Extra , it's very much easy to run multiple API versions from a single Django project. All you have to do is create two or more NinjaAPI instances with different version arguments: api_v1.py : from ninja_extra import NinjaExtraAPI , APIController , route , router @router ( '' ) class MyV1Controller ( APIController ): @route . get ( '/hello' ) def hello ( self ): return { 'message' : 'Hello from V1' } @route . get ( '/example' ) def example ( self ): return { 'message' : 'Hello from V1 Example' } api = NinjaExtraAPI ( version = '1.0.0' ) api . register_controllers ( MyV1Controller ) api_ v2 .py: You can reuse your APIControllers and make modifications to specific routes. from ninja_extra import NinjaExtraAPI , route , router from .api_v1 import MyV1Controller @router ( '' ) class MyV2Controller ( MyV1Controller ): @route . get ( '/example' ) def example ( self ): return { 'message' : 'Hello from V2 Example' } api = NinjaExtraAPI ( version = '2.0.0' ) api . register_controllers ( MyV2Controller ) and then in urls.py : ... from api_v1 import api as api_v1 from api_v2 import api as api_v2 urlpatterns = [ ... path ( 'api/v1/' , api_v1 . urls ), path ( 'api/v2/' , api_v2 . urls ), ] Now you can go to different OpenAPI docs pages for each version: http://127.0.0.1/api/ v1 /docs http://127.0.0.1/api/ v2 /docs Different business logic In the same way, you can define a different API for different components or areas: ... api = NinjaExtraAPI ( auth = token_auth , urls_namespace = 'public_api' ) ... api_private = NinjaExtraAPI ( auth = session_auth , urls_namespace = 'private_api' ) ... urlpatterns = [ ... path ( 'api/' , api . urls ), path ( 'internal-api/' , api_private . urls ), ] Note If you use different NinjaExtraAPI instances, you need to define different version s or different urls_namespace s. This is the same with NinjaAPI instances","title":"Versoning"},{"location":"tutorial/versioning/#versioning","text":"","title":"Versioning"},{"location":"tutorial/versioning/#different-api-version-numbers","text":"With Django Ninja Extra , it's very much easy to run multiple API versions from a single Django project. All you have to do is create two or more NinjaAPI instances with different version arguments: api_v1.py : from ninja_extra import NinjaExtraAPI , APIController , route , router @router ( '' ) class MyV1Controller ( APIController ): @route . get ( '/hello' ) def hello ( self ): return { 'message' : 'Hello from V1' } @route . get ( '/example' ) def example ( self ): return { 'message' : 'Hello from V1 Example' } api = NinjaExtraAPI ( version = '1.0.0' ) api . register_controllers ( MyV1Controller ) api_ v2 .py: You can reuse your APIControllers and make modifications to specific routes. from ninja_extra import NinjaExtraAPI , route , router from .api_v1 import MyV1Controller @router ( '' ) class MyV2Controller ( MyV1Controller ): @route . get ( '/example' ) def example ( self ): return { 'message' : 'Hello from V2 Example' } api = NinjaExtraAPI ( version = '2.0.0' ) api . register_controllers ( MyV2Controller ) and then in urls.py : ... from api_v1 import api as api_v1 from api_v2 import api as api_v2 urlpatterns = [ ... path ( 'api/v1/' , api_v1 . urls ), path ( 'api/v2/' , api_v2 . urls ), ] Now you can go to different OpenAPI docs pages for each version: http://127.0.0.1/api/ v1 /docs http://127.0.0.1/api/ v2 /docs","title":"Different API version numbers"},{"location":"tutorial/versioning/#different-business-logic","text":"In the same way, you can define a different API for different components or areas: ... api = NinjaExtraAPI ( auth = token_auth , urls_namespace = 'public_api' ) ... api_private = NinjaExtraAPI ( auth = session_auth , urls_namespace = 'private_api' ) ... urlpatterns = [ ... path ( 'api/' , api . urls ), path ( 'internal-api/' , api_private . urls ), ] Note If you use different NinjaExtraAPI instances, you need to define different version s or different urls_namespace s. This is the same with NinjaAPI instances","title":"Different business logic"}]}